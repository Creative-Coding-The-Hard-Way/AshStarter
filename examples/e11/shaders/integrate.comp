#version 460
#extension GL_ARB_separate_shader_objects: enable
#define DAMPING 0.9

layout (constant_id=1) const int execution_sixe_x = 64;
layout (local_size_x_id = 1) in;

struct Particle {
  vec2 pos;
  vec2 vel;
};

layout(binding = 0) uniform SimulationConfig {
    vec2 dimensions;
    uint particle_count;
} config;

layout(std430, binding = 1) readonly buffer ReadSBO {
    Particle particles[];
} read_sbo;

layout(std430, binding = 2) buffer WriteSBO {
    Particle particles[];
} write_sbo;

layout(push_constant) uniform IntegrationConstants {
  // The integration timestep.
  float dt;
  float x;
  float y;
  float pressed;
} ic;

void main() {
    for (int i = 0; i < 32; i++) {
        uint index = (gl_GlobalInvocationID.x * 32) + i;
        if (index >= config.particle_count) {
            return;
        }
        Particle particle = read_sbo.particles[index];

        // Subdivide the timestep into thirds, and take three small steps
        // This is worth-while because signalling the async fence takes a long
        // time. Therefore it's better to take lots of small steps and use more
        // compute time per dispatch.
        float dt = ic.dt / 10.0;
        for (int j = 0; j < 10; j++) {
            // ------------------
            // Integrate particle position and velocity.

            if (ic.pressed > 0.0) {
                vec2 accel = vec2(ic.x, ic.y) - particle.pos;
                float square_length = dot(accel, accel);
                vec2 norm_accel = accel / sqrt(square_length);
                particle.vel += dt * 50.0 * norm_accel / (square_length + 0.01);
            }

            particle.pos += dt*particle.vel;

            // ---------------------------
            // Enforce boundary conditions

            float right = config.dimensions.x / 2.0;
            float left = -right;
            if (particle.pos.x >= right) {
                particle.pos.x = right * 2 - particle.pos.x;
                particle.vel.x = -particle.vel.x;
            } else if (particle.pos.x <= left) {
                particle.pos.x = left * 2 - particle.pos.x;
                particle.vel.x = -particle.vel.x;
            }

            float top = config.dimensions.y / 2.0;
            float bottom = -top;
            if (particle.pos.y >= top) {
                particle.pos.y = top * 2 - particle.pos.y;
                particle.vel.y = -particle.vel.y;
            } else if (particle.pos.y <= bottom) {
                particle.pos.y = bottom * 2 - particle.pos.y;
                particle.vel.y = -particle.vel.y;
            }
        }

        particle.vel = pow(DAMPING, ic.dt) * particle.vel;

        // ------------------------------------------
        // Write the updated particle into the buffer
        write_sbo.particles[index] = particle;
    }
}
