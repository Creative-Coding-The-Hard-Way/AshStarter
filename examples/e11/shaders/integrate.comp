#version 460
#extension GL_ARB_separate_shader_objects: enable
#define DAMPING 0.50
#define FAR_STOP 2.0
#define MAX_VEL 150.0

layout (constant_id=1) const int execution_sixe_x = 64;
layout (local_size_x_id = 1) in;

struct Particle {
  vec2 pos;
  vec2 vel;
};

layout(binding = 0) uniform SimulationConfig {
    vec2 dimensions;
    uint particle_count;
} config;

layout(std430, binding = 1) buffer SBO {
    Particle particles[];
} sbo;

layout(push_constant) uniform IntegrationConstants {
  // The integration timestep.
  float dt;
  float x;
  float y;
  float left_pressed;
  float right_pressed;
} ic;

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= sbo.particles.length()) {
        return;
    }
    Particle particle = sbo.particles[index];

    float dt = ic.dt;

    // ------------------
    // Integrate particle position and velocity.

    if (ic.left_pressed > 0.0) {
        vec2 accel = vec2(ic.x, ic.y) - particle.pos;
        float square_length = dot(accel, accel);
        float length = sqrt(square_length);
        vec2 norm_accel = accel / length;

        float repel_force = -10000.0;
        if (length < FAR_STOP) {
            float force = repel_force / (length + 0.05);
            particle.vel += dt * force * norm_accel;
        }

        float attract_force = 10000.0;
        if (length > FAR_STOP) {
            particle.vel += dt * (attract_force / (length + 0.05)) * norm_accel;
        }
    }

    if (ic.right_pressed > 0.0) {
        vec2 accel = vec2(ic.x, ic.y) - particle.pos;
        float square_length = dot(accel, accel);
        float length = sqrt(square_length);
        vec2 norm_accel = accel / length;

        float attract_force = 50000.0;
        if (length > 0.25) {
            particle.vel += dt * (attract_force / (square_length + 0.05)) * norm_accel;
        }
    }

    particle.pos += dt*particle.vel;

    // ---------------------------
    // Enforce boundary conditions

    float right = config.dimensions.x / 2.0;
    float left = -right;
    if (particle.pos.x >= right) {
        particle.pos.x = right * 2 - particle.pos.x;
        particle.vel.x = -particle.vel.x;
    } else if (particle.pos.x <= left) {
        particle.pos.x = left * 2 - particle.pos.x;
        particle.vel.x = -particle.vel.x;
    }

    float top = config.dimensions.y / 2.0;
    float bottom = -top;
    if (particle.pos.y >= top) {
        particle.pos.y = top * 2 - particle.pos.y;
        particle.vel.y = -particle.vel.y;
    } else if (particle.pos.y <= bottom) {
        particle.pos.y = bottom * 2 - particle.pos.y;
        particle.vel.y = -particle.vel.y;
    }

    particle.vel *= pow(DAMPING, dt);

    float length = length(particle.vel);
    if (length > MAX_VEL) {
        particle.vel *= (MAX_VEL / length);
    }

    // ------------------------------------------
    // Write the updated particle into the buffer
    sbo.particles[index] = particle;
}
